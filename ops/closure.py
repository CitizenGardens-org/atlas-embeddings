from __future__ import annotations

from dataclasses import dataclass
from fractions import Fraction as Q
from typing import Dict, Iterable, List, Tuple, Set

from core.resgraph import ResGraph, Vertex, Vector, dot


def reflect(v: Vector, r: Vector) -> Vector:
    """Reflect ``v`` across the hyperplane orthogonal to ``r``.

    The formula uses the exact rational inner product and therefore keeps
    every coordinate as a :class:`fractions.Fraction`.  The root ``r`` is
    assumed to have non-zero norm.  The implementation mirrors the standard
    reflection formula ``s_r(v) = v - 2*(v·r)/(r·r) * r``.
    """
    rr = dot(r, r)
    if rr == Q(0):  # pragma: no cover - defensive guard
        raise ValueError("cannot reflect across a zero vector")
    coeff = (Q(2) * dot(v, r)) / rr
    return tuple(v[i] - coeff * r[i] for i in range(len(v)))


def RC(G: ResGraph) -> ResGraph:
    """Return the smallest supergraph of ``G`` closed under reflections.

    All labels are treated as roots; the closure iteratively applies the
    simple reflections generated by the current set of roots until no new
    labels appear.  Vertex names in the returned graph are deterministically
    assigned in lexicographic order of the labels.
    """
    seeds: Set[Vector] = {G.λ[v] for v in G.V}
    ordered: List[Vector] = sorted(seeds)
    changed = True
    while changed:
        changed = False
        current = list(seeds)
        for r in ordered:
            for v in current:
                w = reflect(v, r)
                if w not in seeds:
                    seeds.add(w)
                    changed = True
        if changed:
            ordered = sorted(seeds)

    sorted_roots = sorted(seeds)
    Vnew = [f"r{i}" for i in range(len(sorted_roots))]
    mapping: Dict[Vector, Vertex] = {lab: name for name, lab in zip(Vnew, sorted_roots)}
    lam = {mapping[lab]: lab for lab in sorted_roots}

    labels_in_U = {G.λ[u] for u in G.U}
    Unew = frozenset(mapping[lab] for lab in sorted_roots if lab in labels_in_U)

    return ResGraph(V=frozenset(Vnew), λ=lam, U=Unew, Φ=G.Φ)
