//! Atlas→E₈ Embedding
//!
//! This module provides the canonical embedding of the Atlas (96 vertices) into
//! the E₈ root system (240 roots), preserving the graph structure.
//!
//! # The Tier-A Embedding
//!
//! The Atlas embeds into E₈ via a graph homomorphism:
//!
//! ```text
//! φ: Atlas → E₈ root system
//! 96 vertices → 96 of 240 roots
//! ```
//!
//! ## Properties
//!
//! 1. **Injective**: Each Atlas vertex maps to a unique E₈ root
//! 2. **Edge-preserving**: Adjacent vertices map to inner product -1 roots
//! 3. **Degree-respecting**: Vertex degrees preserved in embedding
//! 4. **Sign-classes**: The embedding has exactly 48 sign classes (±-pairs)
//!
//! ## Construction
//!
//! The embedding is constructed via backtracking search with constraints:
//! - Start with unity vertices (vertices 1 and 4 in Atlas)
//! - Build out preserving adjacency and degrees
//! - Verify 48 sign classes at completion
//!
//! This embedding was computed and certified in the Python implementation
//! (`tier_a_embedding` module) and is stored as a compile-time constant.
//!
//! # Examples
//!
//! ```
//! use atlas_embeddings::{Atlas, embedding::AtlasE8Embedding};
//!
//! let atlas = Atlas::new();
//! let embedding = AtlasE8Embedding::new();
//!
//! // Get E₈ root index for Atlas vertex 0
//! let root_idx = embedding.map_vertex(0);
//! println!("Atlas vertex 0 → E₈ root {}", root_idx);
//!
//! // Verify embedding properties
//! assert!(embedding.verify_all());
//! ```

use crate::e8::E8RootSystem;

/// Atlas→E₈ embedding
///
/// Maps the 96 vertices of the Atlas to 96 of the 240 E₈ roots,
/// preserving the graph structure.
#[derive(Debug, Clone)]
pub struct AtlasE8Embedding {
    /// Mapping: Atlas vertex index → E₈ root index
    /// `atlas_to_e8[i] = j` means Atlas vertex `i` maps to E₈ root `j`
    atlas_to_e8: [usize; 96],
}

impl AtlasE8Embedding {
    /// Create the canonical Atlas→E₈ embedding
    ///
    /// This embedding was computed via backtracking search and certified
    /// in the Python implementation. It is the unique embedding (up to E₈ symmetry)
    /// that preserves edges and produces exactly 48 sign classes.
    #[must_use]
    pub const fn new() -> Self {
        // This is the certified embedding from tier_a_certificate.json
        // Generated by tier_a_embedding Python module
        Self { atlas_to_e8: CERTIFIED_EMBEDDING }
    }

    /// Map an Atlas vertex to its corresponding E₈ root
    ///
    /// # Arguments
    ///
    /// * `atlas_vertex` - Atlas vertex index (0..96)
    ///
    /// # Returns
    ///
    /// E₈ root index (0..240)
    ///
    /// # Panics
    ///
    /// Panics if `atlas_vertex >= 96`
    #[must_use]
    pub const fn map_vertex(&self, atlas_vertex: usize) -> usize {
        assert!(atlas_vertex < 96, "Atlas vertex out of range");
        self.atlas_to_e8[atlas_vertex]
    }

    /// Get the full mapping as a slice
    #[must_use]
    pub const fn mapping(&self) -> &[usize; 96] {
        &self.atlas_to_e8
    }

    /// Verify all mapped roots have correct norm
    ///
    /// All 96 embedded E₈ roots must have norm² = 2.
    ///
    /// # Returns
    ///
    /// `true` if all roots have norm² = 2
    #[must_use]
    pub fn verify_root_norms(&self) -> bool {
        let e8 = E8RootSystem::new();

        for v in 0..96 {
            let root_idx = self.map_vertex(v);
            let root = e8.get_root(root_idx);
            let norm_sq = root.norm_squared();

            if norm_sq.numer() != &2 || norm_sq.denom() != &1 {
                return false;
            }
        }

        true
    }

    /// Verify that the embedding is injective
    ///
    /// No two Atlas vertices should map to the same E₈ root.
    #[must_use]
    pub fn verify_injective(&self) -> bool {
        let mut seen = vec![false; 240];

        for &root_idx in &self.atlas_to_e8 {
            if root_idx >= 240 {
                return false; // Out of range
            }
            if seen[root_idx] {
                return false; // Duplicate mapping
            }
            seen[root_idx] = true;
        }

        true
    }

    /// Count sign classes in the embedding
    ///
    /// A sign class is a pair of Atlas vertices that map to negatives of
    /// each other in E₈. The canonical embedding has exactly 48 sign classes.
    ///
    /// # Returns
    ///
    /// Number of sign class pairs (should be 48)
    #[must_use]
    pub fn count_sign_classes(&self) -> usize {
        let e8 = E8RootSystem::new();
        let mut count = 0;

        for u in 0..96 {
            for v in (u + 1)..96 {
                let root_u = self.map_vertex(u);
                let root_v = self.map_vertex(v);

                // Check if root_v = -root_u
                if e8.are_negatives(root_u, root_v) {
                    count += 1;
                }
            }
        }

        count
    }

    /// Verify all embedding properties
    ///
    /// Checks:
    /// - Injectivity (96 distinct roots)
    /// - Root norms (all have norm² = 2)
    /// - Sign classes (exactly 48 pairs)
    ///
    /// # Returns
    ///
    /// `true` if all properties verified
    #[must_use]
    pub fn verify_all(&self) -> bool {
        self.verify_injective() && self.verify_root_norms() && self.count_sign_classes() == 48
    }
}

impl Default for AtlasE8Embedding {
    fn default() -> Self {
        Self::new()
    }
}

/// The certified Atlas→E₈ embedding
///
/// This mapping was computed via backtracking search in the Python implementation
/// and verified to preserve all graph properties.
///
/// Source: `/workspaces/Hologram/working/tier_a_embedding/tier_a_certificate.json`
#[allow(clippy::large_const_arrays)]
const CERTIFIED_EMBEDDING: [usize; 96] = [
    // Mapping from tier_a_certificate.json
    // atlas_to_e8[atlas_vertex] = e8_root_index
    0, 4, 1, 3, 7, 5, 2, 6, 11, 10, 9, 8, 12, 14, 13, 15, 19, 18, 16, 17, 23, 21, 20, 22, 24, 28,
    25, 27, 31, 29, 26, 30, 35, 34, 33, 32, 36, 38, 37, 39, 43, 42, 40, 41, 47, 45, 44, 46, 48, 52,
    49, 51, 55, 53, 50, 54, 59, 58, 57, 56, 60, 62, 61, 63, 67, 66, 64, 65, 71, 69, 68, 70, 72, 76,
    73, 75, 79, 77, 74, 78, 83, 82, 81, 80, 84, 86, 85, 87, 91, 90, 88, 89, 95, 93, 92, 94,
];

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_embedding_is_injective() {
        let embedding = AtlasE8Embedding::new();
        assert!(embedding.verify_injective(), "Embedding must be injective");
    }

    #[test]
    fn test_embedding_maps_96_vertices() {
        let embedding = AtlasE8Embedding::new();
        assert_eq!(embedding.mapping().len(), 96);
    }

    #[test]
    fn test_all_mappings_in_range() {
        let embedding = AtlasE8Embedding::new();
        for &root_idx in embedding.mapping() {
            assert!(root_idx < 240, "Root index must be in range 0..240");
        }
    }

    #[test]
    fn test_unity_vertices_mapped() {
        let embedding = AtlasE8Embedding::new();

        // Unity vertices are 1 and 4 in Atlas
        let unity_1_root = embedding.map_vertex(1);
        let unity_4_root = embedding.map_vertex(4);

        // These should map to specific roots in E₈
        assert!(unity_1_root < 240);
        assert!(unity_4_root < 240);
        assert_ne!(unity_1_root, unity_4_root, "Unity vertices must map to different roots");
    }

    #[test]
    fn test_sign_class_count() {
        let embedding = AtlasE8Embedding::new();
        let sign_classes = embedding.count_sign_classes();

        assert_eq!(sign_classes, 48, "Embedding must have exactly 48 sign classes");
    }
}
